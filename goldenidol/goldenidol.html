<html>
<head>
	<style>
		
		@import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
		
		body {
			font-family: "VT323";
			font-size: 34px;
			background-color:black;
			margin:0;
			padding:3% 5%;
		}
		
		.holder{
			position:relative;
			height:500px;
		}
		
		.field{
			display: inline-block;
			width:100px;
			font-size: .8em;
			color:#fffffb;
			border-radius:8px;
			margin: 0px 4px;
			text-align:center;
		}
		
		.empty {
			height: .8em;
			border:1px solid black;
			transform: translateY(4px);
		}
		
		.filled-border{
			display:inline-block;
			background-color: #c1b784;
			border:2px solid #c1b784;
			margin: 0px 10px;
			box-shadow: 0px 1px 1px #999c85;
		}
		
		.filled {
			border-radius:8px;
			background-color: #68443b;
			margin:0;
		}
		
		.word{
			cursor: grab;
		}
		
		.name{
			background-color: #68443b;
		}
		
		.noun{
			background-color: #8f7b42;
		}
		
		.dragging {
			opacity:0;
		}
		
		.ghost{
			position:absolute;
			top:-1000px;
		}
		
		.darken {
			background-image: linear-gradient(rgba(0, 0, 0, 0.3),rgba(0, 0, 0, 0.3))
		}
		
		.hidden{
			display:none !important;
		}
		
		.overlay{
			
		}
		
		.border{
			position:relative;
			border-width: 2px;
			border-style: solid;
			border-color: #7b7355 #918e73 #918e73 #7b7355;
		}
		
		.border::after{
  		  content: "";
  		  position: absolute;
  		  top: 0;
  		  left: 0;
		  right:0;
		  bottom:0;
		  margin:-4px;
		  border-width: 2px;
		  border-style: solid;
		  border-color: #918e73 #7b7355 #7b7355 #918e73;
		  pointer-events: none;
		}
		
		#exploring{
			width:100%;
			height:100%;
			position:absolute;
			background-image: url('img/bg.gif');
			background-repeat: repeat;
		}
		
		#thinking{
			display:flex;
			width:100%;
			height:100%;
		}
		
		.scrollnotes{
			background-color:#25243a;
			text-align:center;
			color:#fffeff;
			font-size:.8em;
		}
		
		.textholder {
			color: #433047;
			background-color:#d4dff9;
			font-size:1em;
			padding:3% 5%;
			flex-grow:1;
		}
		
		.exploringthinking{
			position:absolute;
			top:0;
			left:0;
			color:#b8bb7a;
			background-color:#25243a;
			font-size:.8em;
			display:inline;
			padding: 0px 10px;
		}
		
		.exploringthinking:hover{
			color:#e6eaa0;
			cursor:pointer;
		}
		
		#arrow{
			display: inline-block;
			font-size:1.2em;
			  transform-origin: center;
			  transition: transform 0.5s ease;
			}
		
		.rotate {
		  transform: rotateZ(180deg);
		}
		
		.bottomholder{
			display:flex;
			background-color:#0c1408;
			padding:8px;
			box-sizing: content-box;
			height:100px;
		}
		
		.gotwordsholder{
			color:#858692;
			flex-basis:10%;
			text-align:right;
		}
		
		.sparkle{
			display:inline-block;
			cursor: pointer;
			position:relative;
		}
		
		.sparkle:hover;{
		}
		
		.red{
			
		}
		
		.explorewindow{
			display:inline-block;
			position:absolute;
			top:50%;
			left:50%;
			background-color:#26233c;
			color:#abb1c1;
			padding:8px 20px;
			font-size:1em;
			max-width:50%;
		}
		
		.wordtoget{
		    display:inline-block;
			text-decoration: underline red;
			cursor:grab;
		}
		
		.wordtoget:hover;{
		}
		
		.wordwasgot{
			text-decoration: dotted underline red;
		}
		
		*{
			outline: 1px solid red;
		}
		
	</style>
</head>
<body>

	<div class="holder">
	
	<div id="exploring">
		
		<div class="sparkle" style="left:20%;top:50%;" data-target="window1">✧</div>
		
		<div class="explorewindow border hidden" id="window1">hey <span class="wordtoget" id="Albert">Albert</span> blah blah blah <span class="wordtoget" id="Thumb">Thumb</span></div>
		
	</div>
	
	<div id="thinking" class="hidden">
		
		<div style="display:flex;flex-direction:column;flex-grow:1;flex-basis:0;">
			<div class="scrollnotes border">The scroll is not filled in.</div>
			<div class="textholder border">
				<span class="field empty name" id="Albert"></span><span class="field empty name" id="Cloudsley"></span> pushed <span class="field empty name" id="Oberon"></span><span class="field empty name" id="Geller"></span> from a cliff in the <span class="field empty noun" id="Horn"></span> of <span class="field empty noun" id="Thumb"></span> on Monkey Paw Island.
			</div>
		</div>
		<div style="display:flex;flex-direction:column;flex-grow:1;flex-basis:0;">
			<div class="scrollnotes border">The scroll is not filled in.</div>
			<div class="textholder border">testing...</div>
		</div>

	</div>
</div>
	
	<div class="bottomholder border" id="bottomholder">
		<div id="wordholder" style="flex-grow: 1;"></div>
		<div class="gotwordsholder" id="gotwordsholder"><span id="gotwordsnum"></span>/<span id="maxgotwords"></span></div>
	</div>
	
	<div class="exploringthinking border" id="exploringthinking">Exploring <span id="arrow">⟻&emsp;</span> Thinking</div>
	
	<script>
		
		const worddata = [
			{
				"word": "Albert",
				"type": "name",
				"found": false
			},
			{
				"word": "Cloudsley",
				"type": "name",
				"found": true
			},
			{
				"word": "Oberon",
				"type": "name",
				"found": true
			},
			{
				"word": "Geller",
				"type": "name",
				"found": false
			},
			{
				"word": "Horn",
				"type": "noun",
				"found": true
			},
			{
				"word": "Thumb",
				"type": "noun",
				"found": false
			}
		]

		const holes = document.querySelectorAll('.empty');

		const exploring = document.getElementById('exploring');
		const thinking = document.getElementById('thinking');
		const arrow = document.getElementById('arrow');
		var expthink = document.getElementById('exploringthinking');
		var bottomholder = document.getElementById('bottomholder');
		var wordholder = document.getElementById('wordholder');
		
		var gotwordsholder = document.getElementById('gotwordsholder');
		var gotwordsnumholder = document.getElementById('gotwordsnum');
		var maxgotwordsholder = document.getElementById('maxgotwords');
		var gotwordsnum = 0;
		var maxgotwords = worddata.length;
		
		var dragged = null;
		
		var bottomrect = bottomholder.getBoundingClientRect();
		var bottomwidth = Math.round(bottomrect.width);
		var bottomheight = Math.round(bottomrect.height);
		var expthinkrect = expthink.getBoundingClientRect();
		var expthinkwidth = Math.round(expthinkrect.width);
		var expthinkheight = Math.round(expthinkrect.height);
		expthink.style.top = (Math.round((bottomrect.top) - (expthinkheight))).toString() + "px"
		expthink.style.left = (Math.round((bottomrect.left) + (.5 * bottomwidth) - (.5 * expthinkwidth))).toString() + "px"
		
		const sparkles = document.querySelectorAll(".sparkle");

		sparkles.forEach(sparkle => {
			console.log("sparkling")
		  sparkle.addEventListener('click', function() {
			  console.log("clicking")
		    const targetWindowId = sparkle.dataset.target;
		    const targetWindow = document.getElementById(targetWindowId);
		    if (targetWindow) {
		      targetWindow.classList.toggle('hidden');
			  console.log(targetWindow)
		    }
		  });
		});
		
		const wordstoget = document.querySelectorAll('.wordtoget');
		
		worddata.forEach((word) => {
			if(word.found === true){
				console.log("adding "+word)
				addword(word);
			}
		});
		
		function addword(word){
			var newword = document.createElement("span");
			newword.classList.add("field","word");
			newword.classList.add(word.type);
			newword.textContent = word.word;
			newword.draggable = true;
			wordholder.appendChild(newword);
	        newword.addEventListener('dragstart', dragStart);
	        newword.addEventListener('dragend', dragEnd);
			gotwordsnum++;
			maxgotwordsholder.textContent = maxgotwords.toString();
			gotwordsnumholder.textContent = gotwordsnum.toString();
		}
		
	    holes.forEach(hole => {
	        hole.addEventListener('dragover', dragOver);
	        hole.addEventListener('drop', drop);
	    });
		
	    wordstoget.forEach(word => {
	        word.addEventListener('click', getword)
	    });
		
		function getword(event){
			console.log(event.target);
			event.target.classList.remove('wordtoget');
			event.target.classList.add('wordwasgot');
			event.target.removeEventListener('click',getword)
			findentry(event.target.id).found = true;
			addword(findentry(event.target.id));
		}
		
		function findentry(thisword) {
		  for (var i = 0; i < worddata.length; i++) {
		    if (worddata[i].word === thisword) {
		      return worddata[i];
		    }
		  }
		  return null;
		}

	    function dragStart(event) {
			const nameghost = document.createElement("span");
			nameghost.classList.add("field","word","darken");
			if (event.target.classList.contains("name")){
				nameghost.classList.add("name");
			}
			else if (event.target.classList.contains("noun")){
				nameghost.classList.add("noun");
			}
			nameghost.id = "ghost";
			nameghost.classList.add("ghost");
			nameghost.textContent = event.target.textContent;
			document.body.appendChild(nameghost);
			event.dataTransfer.setDragImage(nameghost, 0, 0);
			event.target.classList.add('dragging');
			dragged = event.target;
	    }

	    function dragEnd(event) {
			event.target.classList.remove('dragging');
			var ghost = document.getElementById("ghost");
			if (ghost.parentNode) {
				ghost.parentNode.removeChild(ghost);
			}
	    }

	    function dragOver(event) {
	        event.preventDefault();
	    }
		
	    function drop(event) {
	        event.preventDefault();
			
			console.log(dragged);
			
			if (event.target.id === dragged.textContent){
				event.target.className = '';
				event.target.classList.add("filled-border");
				const filled = document.createElement("span");
				filled.classList.add("field","filled");
				if (dragged.classList.contains("name")){
					filled.classList.add("name");
				}
				else if (dragged.classList.contains("noun")){
					filled.classList.add("noun");
				}
				filled.textContent = dragged.textContent;
				event.target.appendChild(filled);
			    event.target.removeEventListener('dragover', dragOver);
			    event.target.removeEventListener('drop', drop);
			
				dragged.remove();
			}
	    }
		
		expthink.addEventListener('click', function() {
		  arrow.classList.toggle('rotate');
		  exploring.classList.toggle('hidden');
		  thinking.classList.toggle('hidden');
		});
		
		/*
		
		todo:
		
		change underline container to absolute
		
		open and close underline container with overlay
		
		work on being able to continue to move words around
		
		check accuracy when filled out
		
		lock in when correctly filled out
		
		*/
		
	</script>
	
</body>
</html>